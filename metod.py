# методы строк str
string = 'stroka122ok3'
string.upper()  # возвращает копию строки с большими буквами
string.lower()  # возвращает копию строки с маленькими буквами
string.casefold()  # возвращает копию строки в нижнем регистре, приводя агрессивно
string.title()  # возвращает копию строки, переводя первую букву КАЖДОГО слова в верхний регистр,
# остальные в нижний
string.capitalize()  # возвращает копию строки, переводя 1 символ строки в верхний регистр,
# остальные в нижний
string.count('o', 1, 2)  # возвращает количество сколько раз 'o' встречается
# в строке, начиная с 1 индекса, по 2 индекс НЕВКЛЮЧИТЕЛЬНО

string.find('a12', 1, 2)  # ищет полное вхождение 'a12' в строку, возвращает ИНДЕКС
# первого вхождения, начинает с 1 индекса, по 2 НЕВКЛЮЧИТЕЛЬНО, если нет, возвращает -1
string.rfind('a12', 1, 2)  # тоже самое, только с поиск с конца
string.index('a12', 1, 9)  # тоже самое, но в случае не удачи ОШИБКА ValueError
string.replace('ok', 'ook', 2)  # ищет все вхождения 'ok', возвращает строку,
# заменяя искомое на 'ook', в количестве 2 раз

string.isalpha()  # возвращает True если строка состоит из букв, и False если нет
string.isdigit()  # возвращает True если строка состоит из цифр, и False если нет
string.isdecimal()  # Тоже самое
string.isalnum()  # возвращает True если строка состоит из букв и цифр, и False если нет
string.isascii()  # возвращает True если строка состоит символов ASCII, и False если нет
string.isspace()  # возвращает True если строка состоит из пробельных символов
string.istitle()  # возвращает True если первый символ строки большая буква
string.startswith('str')  # возвращает True если строка начинается с 'str'
string.endswith('str')  # возвращает True если строка заканчивается на 'str'

string.rjust(20, 'n')  # возвращает строку дополненную до 20 символов, символом 'n' слева
string.ljust(20, 'n')  # возвращает строку дополненную до 20 символов, символом 'n' справа
string.center(20)  # возвращает строку стоящую по центру, дополненную до 20 символов

string.split('a')  # разбивает строку по символу 'a'(по умолчание пробел), возвращает СПИСОК
'=='.join(['1', '22'])  # соединяет строки принимаемого списка, соединяя их строкой '==' возвращает СТРОКУ
''.join([str(i) for i in [1, 2, 3, 4, 5]]) # если надо привратить инт в строку и соединить

string.strip()  # возвращает строку с удаленными пробельными символами по всей строке
string.lstrip()  # возвращает строку с удаленными пробельными символами только слева
string.rstrip()  # возвращает строку с удаленными пробельными символами только справа
string.partition('ka1')  # возвращает картеж, разбивая строку на 3 части, до ПЕРВОГО 'ka1', сам 'ka1', и после него
# в случае ненахода, возвращает саму строку и 2 пустых строки
string.rpartition('ka1')  # тоже самое, но начинает поиск с конца
string.swapcase()  # возвращает строку переводя регистры: нижний в верхни, а верних в нижний

# string.format() ПОДРОБНЕЕ ТУТ https://pythonworld.ru/osnovy/formatirovanie-strok-metod-format.html
"hello, {}!".format("123")  # Возвращает отфарматированную строку, вместо {} значение "123"
"hello, {1}{0}{1}!".format("123", True)  # если установить значения в скобках, сработает по индексам
"hello, {lol}{lah}!".format(lol='1', lah='2')  # так же можно установить значения по ключам
cart = {'lul': '333'}
"hello, {lul}!".format(**cart)  # может принимать разыменованные словари

string.encode()  # что-то сложное, кодирует строку в байтсроку,
# можно перекодировать русские символы в что то типо \\u043a
#####################################################################################################
# методы списков(массивы) list
listed = list("123")
listed.insert(2, '33')  # вставляет значение '33' по индексу 2, возвращает None
listed.append([1, 2, 3])  # принимает 1 значение, и добавляет его в конец списка, возвращает None
listed.extend(['1', 2, 3])  # тоже самое, но принимаемое значение итерируемое, списки, картежи, словари
# будут раскрыты, и их значения добавлены в конец, возвращает None
listed.copy()  # возвращает копию списка
listed.count('1')  # возвращает, сколько раз 'a', входит в список
listed.index('2', 1, 6)  # возвращает индекс первого нахождения '2', начиная поиск с 1, 6 невключительно
# если индекс не найден, вернёт ошибку.
listed.pop(1)  # удаляет значение под индексом 1(по умолчанию с конца), и возвращает его.
listed.remove('3')  # удаляет первое ЗНАЧЕНИЕ '3', если значения нет ОШИБКА ValueError
listed.reverse()  # переворачивает список, возвращает None
listed.clear()  # очищает список
listed.sort()  # сорирует список, по умолчанию по алфовиту, возвращает None
# может принимать ключи(любая функция) и reverse=True, переворачивает список после сортировки
import copy

copy.deepcopy(listed)  # глубокое копирование, помогает скопроивать с вложными списками

#####################################################################################################
# методы множества(неитерируемый, неповторяющийся список) set
sett = {"1", "2", "3", "4", }
sett.add('9')  # добавляет значение в множество, возвращает None
sett.update(['1', '2', '8'])  # добавляет итерируемую последовательностЬ, раскрывая её, возвращает None
sett.copy()  # возвращает копию множества

sett.intersection({'1', '2'})  # возвращает пересечение множества, с принимаемым значением.
sett.intersection_update({'1'})  # тоже самое, но присваивает результат в множество sett, возвращает None
sett.difference({1, 2, 3})  # возвращает множетсво sett, но без элементов принимаемого значения
sett.difference_update({1, 2, 3})  # тоже самое, но присваивает результат в множество sett, возвращает None
sett.symmetric_difference([2, 3])  # Возвращает не повторяющиеся значения (a ^ b)
sett.symmetric_difference_update([2, 3])  # тоже самое, но присваивает результат в множество sett, возвращает None
sett.union({1, 2, 3})  # возвращает объединенное множество c принимаемым значением

sett.issubset([1, 2, 3])  # проверяет, входит ли множество sett в принимаемое значение? возвращает True
sett.issuperset([1, 2, 3])  # проверяет, входил ли принимаемое в множество sett? возвращает True
sett.isdisjoint([2, 3, 4])  # проверяет, пересекаются ли множества? возвращает True если НЕТ!

sett.discard('2')  # удаляет '4' из множества по ЗНАЧЕНИЮ, возвращает None, без ошибок
sett.remove('1')  # удаляет '2' из множества по ЗНАЧЕНИЮ, возвращает None, С ОШИБКОЙ!
sett.pop()  # удаляет случайный элемент, и возвращает его
sett.clear()  # очищает множество, возвращает None
#####################################################################################################
# методы картежи(конст.массивы) tuple
tupl = (1, 2, 3, 4, 5, 6, 7)
tupl.count('a')  # возвращает, сколько раз 'a', входит в список
tupl.index(2, 1, 6)  # возвращает индекс первого нахождения '2', начиная поиск с 1, 6 невключительно
# если индекс не найден, вернёт ошибку.
#####################################################################################################
# методы словари(структуры)
dic = {'mos': '495', 'pit': '812', 'pen': '8412'}
dict.fromkeys(['a', 'b', 'c'], 100)  # возвращает словарь из ключей а,б,ц, со значениями 100
# не важно с каким именем словаря вызывать


dic.get('pit', "NNN")  # возвращает значение ключа pit, если ключа нет, вернёт NNN (None по умолчанию)
dic.setdefault('lol', 11)  # возвращает значение ключа lol, если ключа нет,
# вернёт 11 (None по умолчанию) и при этом изменит словать добавив этот ключ туда

dic.keys()  # возвращает все ключи словаря, тип объекта dict_keys
dic.values()  # возвращает все значения словаря. тип объекта dict_values
dic.items()  # возвращает коллекцию, в которой содерщатся ключ+значение (картежи) тип объекта dict_items
# выше идущие 3 метода хороши для цикла for

dic.pop('lol1', 'lol')  # возвращает значение ключа lol1, и удаляет ключ из словаря,
# если ключа нет, вернёт lol, если второй парамтер не установлен - ошибка
dic.popitem()  # удаляет случайный ключ, возвращает пару ключ+значение(картеж), ошибка если удалять нечего
del dic['mos']  # функция del удаляет ключ с именем mos, с ошибкой если нет такого ключа
dic.clear()  # очищает словарь

a = {1, 2, 3, 4, 5, 6}
b = {5, 6, 7, 8, 9}
# a & b  # возвращает пересекающиеся значения
# a | b  # возвращает объеденённые множества
# a - b  # возвращает множество а, но без элементов б
# ^ b  # возвращает все НЕ совпадающие значения
#
# Тернарный оператор, синтаксис:
# результат1 если условие(истина) иначе результат 2
# usl = False
# name = 'Max' if usl else 'Empty'
# print(name)
#
#
# def torf(ch):
# 	list_ch = list(ch)
# 	for i in range(len(list_ch)):
# 		list_ch[i] = list_ch[i].lower() if i % 2 != 0 else list_ch[i].upper()
# 	return "".join(list_ch)
#
#
# stroka = "слово"
# print(torf(stroka))
#
#
# def pass_check(password):
# 	return True if password == "Jack" else False
#
#
# print('Wellcome!' if (True if input() == '123' else False) else 'Wrong password')
#
# strokabyt = "Hello МИР".encode('utf-8')  # кодировка строки в байт строку
# # print(strokabyt)
# stroka = strokabyt.decode('utf-8')  # декодировка байт строки в строку
# # print(stroka)

import math  # импортирует целиком библеотеку
import random as rd  # вызов модуля с псевдонимом rd
from math import *  # импортирует всё содержимое модуля, чтобы вызывать его без имени
from random import randint  # импортирует только определенные модули внуторь кода

if __name__ == '__main__':  # таким способом можно ограничить импорт скриптов
	chislo_pi = math.pi
	chislo_pi = pi  # тоже работает т.к. импортирован модуль внуторь моей программы
	rd.randint(1, 10)
	randint(1, 100)  # тоже работает т.к. импортировать отдельно
